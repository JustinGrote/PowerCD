function Get-PowerCDVersion {
    [Cmdletbinding()]
    param (
        [Switch]$As
    )

    $ModulePath = FastImportModule GitVersion.CommandLine -Package
    $GitVersionEXE = [IO.Path]::Combine($ModulePath,'tools','GitVersion.exe')

    #Fetch GitVersion if required from NuGet
    # $GitVersionPackageName = 'gitversion.commandline'
    # $GitVersionPackageMinVersion = '4.0.0'
    # $PackageParams = @{
    #     Name = $GitVersionPackageName
    #     MinimumVersion = $GitVersionPackageMinVersion
    # }

    # if ($IsAppVeyor -and $IsLinux) {
    #     #Appveyor Ubuntu can't run the EXE for some dumb reason as of 2018/11/27, fetch it as a global tool instead
    #     #Fetch Gitversion as a .net Global Tool
    #     $dotnetCMD = (get-command dotnet -CommandType Application -errorAction stop | select -first 1).source
    #     $gitversionEXE = (get-command dotnet-gitversion -CommandType Application -errorAction silentlycontinue | select -first 1).source
    #     if ($dotnetCMD -and -not $gitversionEXE) {
    #         write-build Green "Task $task - Installing dotnet-gitversion"
    #         #Skip First Run Setup (takes too long for no benefit)
    #         $ENV:DOTNET_SKIP_FIRST_TIME_EXPERIENCE = $true
    #         Invoke-Expression "$dotnetCMD tool install --global GitVersion.Tool --version 4.0.1-beta1-47"
    #     }
    #     $gitversionEXE = (get-command dotnet-gitversion -CommandType Application -errorAction stop | select -first 1).source
    # } else {
    #     #Fetch Gitversion as a NuGet Package
    #     $GitVersionPackage = Get-Package @PackageParams -erroraction SilentlyContinue
    #     if (!($GitVersionPackage)) {
    #         write-verbose "Package $GitVersionPackageName Not Found Locally, Installing..."

    #         #Fetch GitVersion
    #         $GitVersionPackage = Install-Package @PackageParams -scope currentuser -source 'nuget.org' -force -erroraction stop
    #     }
    #     $GitVersionEXE = [Path]::Combine(((Get-Package $GitVersionPackageName).source | split-path -Parent),'tools','GitVersion.exe')
    # }

    #If this commit has a tag on it, temporarily remove it so GitVersion calculates properly
    #Fixes a bug with GitVersion where tagged commits don't increment on non-master builds.
    $currentTag = git tag --points-at HEAD

    if ($currentTag) {
        write-build DarkYellow "Task $($task.name) - Git Tag $currentTag detected. Temporarily removing for GitVersion calculation."
        git tag -d $currentTag
    }

    #Strip prerelease tags, GitVersion can't handle them with Mainline deployment with version 4.0
    #TODO: Restore these for local repositories, otherwise they just come down with git pulls
    git tag --list v*-* | % {git tag -d $PSItem}

    try {
        #Calculate the GitVersion
        write-verbose "Executing GitVersion to determine version info"

        if ($isLinux -and -not $isAppveyor) {
            #TODO: Find a more platform-independent way of changing GitVersion executable permissions (Mono.Posix library maybe?)
            chmod +x $GitVersionEXE
        }

        $GitVersionOutput = Invoke-Expression "$GitVersionEXE /nofetch"

        #Since GitVersion doesn't return error exit codes, we look for error text in the output in the output
        if ($GitVersionOutput -match '^[ERROR|INFO] \[') {throw "An error occured when running GitVersion.exe in $buildRoot"}
        $SCRIPT:GitVersionInfo = $GitVersionOutput | ConvertFrom-JSON -ErrorAction stop
    } catch {
        write-build Red $GitVersionOutput
        write-error "There was an error when running GitVersion.exe $buildRoot`: $PSItem. The output of the command (if any) is above..."
    } finally {
        #Restore the tag if it was present
        if ($currentTag) {
            write-build DarkYellow "Task $($task.name) - Restoring tag $currentTag."
            git tag $currentTag -a -m "Automatic GitVersion Release Tag Generated by Invoke-Build"
        }
    }

    #if (-not $GitVersionOutput) {throw "GitVersion returned no output. Are you sure it ran successfully?"}
    #if ($PassThruParams.Verbose) {
    #    write-verboseheader "GitVersion Results"
    $GitVersionInfo | format-list | out-string | write-host -fore green
    #}

    # $SCRIPT:ProjectBuildVersion = [Version]$GitVersionInfo.MajorMinorPatch

    # #GA release detection
    # if ($BranchName -eq 'master') {
    #     $Script:IsGARelease = $true
    #     $Script:ProjectVersion = $ProjectBuildVersion
    # } else {
    #     #The regex strips all hypens but the first one. This shouldn't be necessary per NuGet spec but Update-ModuleManifest fails on it.
    #     $SCRIPT:ProjectPreReleaseVersion = $GitVersionInfo.nugetversion -replace '(?<=-.*)[-]'
    #     $SCRIPT:ProjectVersion = $ProjectPreReleaseVersion
    #     $SCRIPT:ProjectPreReleaseTag = $SCRIPT:ProjectPreReleaseVersion.split('-')[1]
    # }

    # write-build Green "Task $($task.name)` - Calculated Project Version: $ProjectVersion"

    # #Tag the release if this is a GA build
    # if ($BranchName -match '^(master|releases?[/-])') {
    #     write-build Green "Task $($task.name)` - In Master/Release branch, adding release tag v$ProjectVersion to this build"

    #     $SCRIPT:isTagRelease = $true
    #     if ($BranchName -eq 'master') {
    #         write-build Green "Task $($task.name)` - In Master branch, marking for General Availability publish"
    #         [Switch]$SCRIPT:IsGARelease = $true
    #     }
    # }

    # #Reset the build dir to the versioned release directory. TODO: This should probably be its own task.
    # $SCRIPT:BuildReleasePath = Join-Path $BuildProjectPath $ProjectBuildVersion
    # if (-not (Test-Path -pathtype Container $BuildReleasePath)) {New-Item -type Directory $BuildReleasePath | out-null}
    # $SCRIPT:BuildReleaseManifest = Join-Path $BuildReleasePath (split-path $env:BHPSModuleManifest -leaf)
    # write-build Green "Task $($task.name)` - Using Release Path: $BuildReleasePath"
}